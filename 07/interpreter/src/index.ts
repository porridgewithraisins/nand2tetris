import { createWriteStream } from "fs";
import * as fs from "fs/promises";
import path from "path";
import { CodeGenerator } from "./translations";
import { fileContents, pipe } from "./util";

main();

async function main() {
    const src = process.argv[2];
    const name = path.basename(src, ".vm");
    const dir = path.dirname(src);

    const dest = path.join(dir, `${name}.asm`);
    const writer = fileWriter(dest);

    const interpreter = pipe(reader).to(cleaner).to(translator).to(minifier).to(writer);
    // each line of VM code in file(s) -> clean -> translate to ASM -> minify -> write to file
    await interpreter.start(src);

    console.log("done");
}

async function* cleaner(lines: AsyncIterable<string>) {
    for await (const line of lines) {
        const cleanLine = line
            .replace(/\/\/.*/, "") // remove comments
            .replace(/\s{2,}/g, " ") // remove extra whitespace
            .trim(); // remove leading and trailing whitespace
        if (cleanLine.length > 0) yield cleanLine;
    }
}

async function* reader(source: string) {
    const statResult = await fs.stat(source);
    if (statResult.isFile()) yield* fileContents(source);
    else for (const file of await fs.readdir(source)) yield* fileContents(path.join(source, file));
}

async function* translator(instructions: AsyncIterable<string>) {
    const codegen = CodeGenerator.instance;

    yield "// This file was generated by Sandy's VM Interpreter\n";

    if (!process.argv.includes("--no-bootstrap")) {
        yield "// Bootstrap code\n";
        yield codegen.generateFor("bootstrap");
    }

    for await (const instruction of instructions) yield codegen.generateFor(instruction);
}

async function* minifier(instructions: AsyncIterable<string>) {
    for await (const instruction of instructions) yield instruction.replace(/(\n)\s+/g, "$1");
}

function fileWriter(file: string) {
    return async (text: AsyncIterable<string>) => {
        const writer = createWriteStream(file);
        for await (const chunk of text) writer.write(chunk);
        writer.close();
    };
}
